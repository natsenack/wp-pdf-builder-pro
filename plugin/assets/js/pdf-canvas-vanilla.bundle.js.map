{"version":3,"file":"js/pdf-canvas-vanilla.bundle.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;;AAEA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AAAA;AAAA;AAAA;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;;AAEA;AACA;AAIA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;;AAEA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;AAOA;AACA;;AAEA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;;AAEA;AAAA;AAAA;AAAA;AAGA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AAAA;AAAA;;AAGA;AAAA;AAGA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAIA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAGA;AAEA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;AAEA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAGA;AAEA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACpfA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAFA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AAAA;AAAA;AACA;AAEA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAxBA;AAAA;AAAA;AAAA;AA0BA;AACA;AACA;AAFA;AAAA;AAAA;AAAA;AAIA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAFA;AAAA;AAAA;AAIA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAFA;AAAA;AAAA;AAIA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AAFA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAJA;AAAA;AAAA;AAAA;AAMA;AACA;AACA;AAFA;AAAA;AAAA;AAAA;AAIA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAFA;AAAA;AAAA;AAIA;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAFA;AAAA;AAAA;AAIA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAFA;AAAA;AAAA;AAIA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AAFA;AAAA;AAAA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAFA;AAAA;AAAA;AAIA;AAAA;;AAGA;AACA;AACA;AAFA;AAAA;AAAA;AAIA;AACA;AACA;;AAEA;AACA;AACA;AAFA;AAAA;AAAA;AAIA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAFA;AAAA;AAAA;AAIA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAFA;AAAA;AAAA;AAIA;AACA;AACA;;AAEA;AACA;AACA;AAFA;AAAA;AAAA;AAIA;AACA;AACA;;AAEA;AACA;AACA;AAFA;AAAA;AAAA;AAIA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAFA;AAAA;AAAA;AAIA;AAEA;AACA;AAEA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AAFA;AAAA;AAAA;AAIA;AACA;AACA;;AAEA;AACA;AACA;AAFA;AAAA;AAAA;AAIA;AACA;AACA;;AAEA;AACA;AACA;AAFA;AAAA;AAAA;AAIA;AACA;AACA;;AAEA;AACA;AACA;AAFA;AAAA;AAAA;AAIA;AACA;AACA;;AAEA;AACA;AACA;AAFA;AAAA;AAAA;AAIA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;;AAEA;AACA;AACA;AAFA;AAAA;AAAA;AAIA;AACA;AAIA;;AAEA;AACA;AACA;AAFA;AAAA;AAAA;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AAFA;AAAA;AAAA;AAIA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AAFA;AAAA;AAAA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAFA;AAAA;AAAA;AAIA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAFA;AAAA;AAAA;AAIA;AACA;AACA;;AAEA;AACA;AACA;AAFA;AAAA;AAAA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAFA;AAAA;AAAA;AAIA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAFA;AAAA;AAAA;AAIA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAFA;AAAA;AAAA;AAIA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AAFA;AAAA;AAAA;AAIA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAFA;AAAA;AAAA;AAIA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAFA;AAAA;AAAA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAFA;AAAA;AAAA;AAIA;AACA;AACA;;AAEA;AACA;AACA;AAFA;AAAA;AAAA;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAFA;AAAA;AAAA;AAGA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAFA;AAAA;AAAA;AAIA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAFA;AAAA;AAAA;AAIA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAFA;AAAA;AAAA;AAIA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAFA;AAAA;AAAA;AAIA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAFA;AAAA;AAAA;AAGA;AAAA;AACA;AACA;;AAEA;AACA;AACA;AAFA;AAAA;AAAA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAFA;AAAA;AAAA;AAGA;AACA;AACA;AAEA;AACA;AAEA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAFA;AAAA;AAAA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AAFA;AAAA;AAAA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AAAA;AAEA;AAEA;AACA;AAAA;AAAA;;AAGA;AACA;;AAEA;AACA;AAAA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA","sources":["webpack://pdfBuilderReact/./assets/js/pdf-canvas-optimizer.js","webpack://pdfBuilderReact/./assets/js/pdf-canvas-vanilla.js"],"sourcesContent":["/**\r\n * PDF Canvas Performance Optimizer\r\n * Optimise les performances du canvas pour une meilleure expérience utilisateur\r\n */\r\n\r\nexport class PDFCanvasPerformanceOptimizer {\r\n    constructor(canvas) {\r\n        this.canvas = canvas;\r\n        this.metrics = {\r\n            fps: 0,\r\n            frameTime: 0,\r\n            renderTime: 0,\r\n            memoryUsage: 0,\r\n            elementCount: 0\r\n        };\r\n\r\n        this.lastFrameTime = performance.now();\r\n        this.frameCount = 0;\r\n        this.fpsUpdateInterval = 1000; // Mise à jour FPS chaque seconde\r\n        this.lastFpsUpdate = performance.now();\r\n\r\n        // Paramètres d'optimisation\r\n        this.settings = {\r\n            targetFps: 60,\r\n            maxElements: 1000,\r\n            lazyLoadThreshold: 50,\r\n            memoryLimit: 128 * 1024 * 1024, // 128MB\r\n            enableProfiling: false\r\n        };\r\n\r\n        // Cache pour les calculs coûteux\r\n        this.cache = new Map();\r\n\r\n        // Gestionnaire de lazy loading\r\n        this.lazyLoader = new LazyLoader(this);\r\n\r\n        // Moniteur de performance\r\n        this.performanceMonitor = new PerformanceMonitor(this);\r\n\r\n        this.init();\r\n    }\r\n\r\n    init() {\r\n        // Démarrer le monitoring\r\n        this.performanceMonitor.start();\r\n\r\n        // Configurer les optimisations\r\n        this.setupOptimizations();\r\n\r\n        console.log('[PDFCanvas] Performance Optimizer initialized');\r\n    }\r\n\r\n    setupOptimizations() {\r\n        // Optimisation du rendu\r\n        this.optimizeRendering();\r\n\r\n        // Optimisation mémoire\r\n        this.optimizeMemory();\r\n\r\n        // Lazy loading des éléments\r\n        this.setupLazyLoading();\r\n    }\r\n\r\n    optimizeRendering() {\r\n        // Utiliser requestAnimationFrame pour un rendu fluide\r\n        this.useRequestAnimationFrame();\r\n\r\n        // Optimiser le rendu des éléments hors écran\r\n        this.optimizeOffscreenRendering();\r\n\r\n        // Utiliser des layers pour améliorer les performances\r\n        this.setupLayerOptimization();\r\n    }\r\n\r\n    optimizeMemory() {\r\n        // Nettoyer le cache régulièrement\r\n        this.setupCacheCleanup();\r\n\r\n        // Optimiser la gestion des événements\r\n        this.optimizeEventHandling();\r\n\r\n        // Monitorer l'utilisation mémoire\r\n        this.setupMemoryMonitoring();\r\n    }\r\n\r\n    setupLazyLoading() {\r\n        // Charger les éléments visibles en priorité\r\n        this.lazyLoader.enable();\r\n\r\n        // Précharger les éléments proches\r\n        this.setupPreloading();\r\n    }\r\n\r\n    // === MONITORING DES PERFORMANCES ===\r\n\r\n    updateMetrics() {\r\n        const now = performance.now();\r\n        this.frameCount++;\r\n\r\n        // Calculer le FPS\r\n        if (now - this.lastFpsUpdate >= this.fpsUpdateInterval) {\r\n            this.metrics.fps = Math.round((this.frameCount * 1000) / (now - this.lastFpsUpdate));\r\n            this.frameCount = 0;\r\n            this.lastFpsUpdate = now;\r\n\r\n            // Avertir si FPS trop bas\r\n            if (this.metrics.fps < 30) {\r\n                console.warn(`[PDFCanvas] Low FPS detected: ${this.metrics.fps}`);\r\n                this.handleLowPerformance();\r\n            }\r\n        }\r\n\r\n        // Mesurer le temps de rendu\r\n        this.metrics.renderTime = now - this.lastFrameTime;\r\n        this.lastFrameTime = now;\r\n\r\n        // Compter les éléments\r\n        this.metrics.elementCount = this.canvas.elements.size;\r\n\r\n        // Mesurer utilisation mémoire (estimation)\r\n        this.metrics.memoryUsage = this.estimateMemoryUsage();\r\n    }\r\n\r\n    estimateMemoryUsage() {\r\n        // Estimation simple basée sur le nombre d'éléments\r\n        const baseMemory = 1024 * 1024; // 1MB base\r\n        const elementMemory = this.metrics.elementCount * 2048; // ~2KB par élément\r\n        return baseMemory + elementMemory;\r\n    }\r\n\r\n    handleLowPerformance() {\r\n        // Réduire la qualité du rendu\r\n        this.reduceRenderQuality();\r\n\r\n        // Désactiver les animations coûteuses\r\n        this.disableExpensiveAnimations();\r\n\r\n        // Activer le lazy loading plus agressif\r\n        this.lazyLoader.aggressiveMode = true;\r\n    }\r\n\r\n    // === OPTIMISATIONS DE RENDU ===\r\n\r\n    useRequestAnimationFrame() {\r\n        // Remplacer les setInterval par requestAnimationFrame\r\n        if (this.canvas.renderLoop) {\r\n            clearInterval(this.canvas.renderLoop);\r\n        }\r\n\r\n        const render = () => {\r\n            this.canvas.render();\r\n            this.updateMetrics();\r\n            requestAnimationFrame(render);\r\n        };\r\n\r\n        requestAnimationFrame(render);\r\n    }\r\n\r\n    optimizeOffscreenRendering() {\r\n        // Ne rendre que les éléments visibles\r\n        this.canvas.shouldRenderElement = (element) => {\r\n            return this.isElementVisible(element);\r\n        };\r\n    }\r\n\r\n    isElementVisible(element) {\r\n        const canvasRect = this.canvas.canvas.getBoundingClientRect();\r\n        const elementBounds = element.getBounds();\r\n\r\n        // Vérifier si l'élément intersecte la zone visible\r\n        return !(elementBounds.right < 0 ||\r\n                elementBounds.left > canvasRect.width ||\r\n                elementBounds.bottom < 0 ||\r\n                elementBounds.top > canvasRect.height);\r\n    }\r\n\r\n    setupLayerOptimization() {\r\n        // Créer des layers pour différents types d'éléments\r\n        this.layers = {\r\n            background: new OffscreenCanvas(1, 1),\r\n            elements: new OffscreenCanvas(1, 1),\r\n            overlay: new OffscreenCanvas(1, 1)\r\n        };\r\n\r\n        this.resizeLayers();\r\n    }\r\n\r\n    resizeLayers() {\r\n        const { width, height } = this.canvas.canvas;\r\n        Object.values(this.layers).forEach(layer => {\r\n            if (layer.width !== width || layer.height !== height) {\r\n                layer.width = width;\r\n                layer.height = height;\r\n            }\r\n        });\r\n    }\r\n\r\n    // === OPTIMISATIONS MÉMOIRE ===\r\n\r\n    setupCacheCleanup() {\r\n        // Nettoyer le cache toutes les 30 secondes\r\n        setInterval(() => {\r\n            this.cleanupCache();\r\n        }, 30000);\r\n    }\r\n\r\n    cleanupCache() {\r\n        const maxAge = 5 * 60 * 1000; // 5 minutes\r\n        const now = Date.now();\r\n\r\n        for (const [key, entry] of this.cache.entries()) {\r\n            if (now - entry.timestamp > maxAge) {\r\n                this.cache.delete(key);\r\n            }\r\n        }\r\n\r\n        // Forcer le garbage collector si disponible\r\n        if (window.gc) {\r\n            window.gc();\r\n        }\r\n    }\r\n\r\n    optimizeEventHandling() {\r\n        // Utiliser l'event delegation\r\n        this.setupEventDelegation();\r\n\r\n        // Debouncer pour les événements fréquents\r\n        this.setupEventDebouncing();\r\n    }\r\n\r\n    setupEventDelegation() {\r\n        // Attacher les événements au container plutôt qu'aux éléments individuels\r\n        const container = this.canvas.canvas.parentElement;\r\n        if (container) {\r\n            container.addEventListener('click', (e) => {\r\n                this.handleDelegatedEvent('click', e);\r\n            });\r\n\r\n            container.addEventListener('mousemove', (e) => {\r\n                this.handleDelegatedEvent('mousemove', e);\r\n            });\r\n        }\r\n    }\r\n\r\n    handleDelegatedEvent(type, event) {\r\n        // Trouver l'élément cible et déclencher l'événement approprié\r\n        const element = this.canvas.findElementAt(event.offsetX, event.offsetY);\r\n        if (element) {\r\n            this.canvas.eventManager.triggerElementEvent(type, element, event);\r\n        }\r\n    }\r\n\r\n    setupEventDebouncing() {\r\n        this.debouncedEvents = new Map();\r\n\r\n        // Debouncer pour les événements de zoom et scroll\r\n        this.debounce('zoom', () => this.handleZoomEvent(), 16); // ~60fps\r\n        this.debounce('scroll', () => this.handleScrollEvent(), 16);\r\n    }\r\n\r\n    debounce(eventType, callback, delay) {\r\n        let timeoutId;\r\n        this.debouncedEvents.set(eventType, () => {\r\n            clearTimeout(timeoutId);\r\n            timeoutId = setTimeout(callback, delay);\r\n        });\r\n    }\r\n\r\n    setupMemoryMonitoring() {\r\n        // Monitorer l'utilisation mémoire\r\n        if ('memory' in performance) {\r\n            setInterval(() => {\r\n                const memInfo = performance.memory;\r\n                console.log(`[PDFCanvas] Memory: ${Math.round(memInfo.usedJSHeapSize / 1024 / 1024)}MB used`);\r\n\r\n                if (memInfo.usedJSHeapSize > this.settings.memoryLimit) {\r\n                    console.warn('[PDFCanvas] High memory usage detected');\r\n                    this.handleHighMemoryUsage();\r\n                }\r\n            }, 10000); // Toutes les 10 secondes\r\n        }\r\n    }\r\n\r\n    handleHighMemoryUsage() {\r\n        // Forcer le nettoyage\r\n        this.cleanupCache();\r\n\r\n        // Réduire le nombre d'éléments en cache\r\n        this.reduceCacheSize();\r\n\r\n        // Demander à l'utilisateur de sauvegarder\r\n        this.canvas.emit('memory-warning');\r\n    }\r\n\r\n    // === LAZY LOADING ===\r\n\r\n    setupPreloading() {\r\n        // Précharger les éléments proches de la zone visible\r\n        this.preloadDistance = 200; // pixels\r\n\r\n        this.canvas.on('viewport-change', () => {\r\n            this.preloadNearbyElements();\r\n        });\r\n    }\r\n\r\n    preloadNearbyElements() {\r\n        const viewport = this.canvas.getViewportBounds();\r\n\r\n        this.canvas.elements.forEach(element => {\r\n            if (this.isElementNearViewport(element, viewport)) {\r\n                this.lazyLoader.loadElement(element);\r\n            }\r\n        });\r\n    }\r\n\r\n    isElementNearViewport(element, viewport) {\r\n        const bounds = element.getBounds();\r\n        const distance = Math.max(\r\n            Math.abs(bounds.left - viewport.left),\r\n            Math.abs(bounds.right - viewport.right),\r\n            Math.abs(bounds.top - viewport.top),\r\n            Math.abs(bounds.bottom - viewport.bottom)\r\n        );\r\n\r\n        return distance <= this.preloadDistance;\r\n    }\r\n\r\n    // === UTILITAIRES ===\r\n\r\n    reduceRenderQuality() {\r\n        // Réduire la résolution du canvas temporairement\r\n        const originalWidth = this.canvas.canvas.width;\r\n        const originalHeight = this.canvas.canvas.height;\r\n\r\n        this.canvas.canvas.width = originalWidth * 0.5;\r\n        this.canvas.canvas.height = originalHeight * 0.5;\r\n\r\n        // Restaurer après 5 secondes de bonnes performances\r\n        setTimeout(() => {\r\n            this.canvas.canvas.width = originalWidth;\r\n            this.canvas.canvas.height = originalHeight;\r\n        }, 5000);\r\n    }\r\n\r\n    disableExpensiveAnimations() {\r\n        // Désactiver les animations coûteuses\r\n        this.canvas.settings.animations = false;\r\n        this.canvas.settings.transitions = false;\r\n    }\r\n\r\n    reduceCacheSize() {\r\n        // Garder seulement les éléments les plus récents\r\n        const maxCacheSize = 50;\r\n        if (this.cache.size > maxCacheSize) {\r\n            const entries = Array.from(this.cache.entries());\r\n            entries.sort((a, b) => b[1].timestamp - a[1].timestamp);\r\n\r\n            // Supprimer les entrées les plus anciennes\r\n            const toDelete = entries.slice(maxCacheSize);\r\n            toDelete.forEach(([key]) => this.cache.delete(key));\r\n        }\r\n    }\r\n\r\n    // === API PUBLIQUE ===\r\n\r\n    getMetrics() {\r\n        return { ...this.metrics };\r\n    }\r\n\r\n    enableProfiling() {\r\n        this.settings.enableProfiling = true;\r\n        console.log('[PDFCanvas] Performance profiling enabled');\r\n    }\r\n\r\n    disableProfiling() {\r\n        this.settings.enableProfiling = false;\r\n        console.log('[PDFCanvas] Performance profiling disabled');\r\n    }\r\n\r\n    destroy() {\r\n        this.performanceMonitor.stop();\r\n        this.lazyLoader.disable();\r\n        this.cache.clear();\r\n    }\r\n}\r\n\r\n// === CLASSES UTILITAIRES ===\r\n\r\nclass LazyLoader {\r\n    constructor(optimizer) {\r\n        this.optimizer = optimizer;\r\n        this.enabled = false;\r\n        this.aggressiveMode = false;\r\n        this.loadedElements = new Set();\r\n    }\r\n\r\n    enable() {\r\n        this.enabled = true;\r\n        console.log('[LazyLoader] Enabled');\r\n    }\r\n\r\n    disable() {\r\n        this.enabled = false;\r\n        console.log('[LazyLoader] Disabled');\r\n    }\r\n\r\n    loadElement(element) {\r\n        if (!this.enabled || this.loadedElements.has(element.id)) {\r\n            return;\r\n        }\r\n\r\n        // Simuler le chargement lazy\r\n        if (this.aggressiveMode) {\r\n            // Mode agressif : charger immédiatement\r\n            this.doLoadElement(element);\r\n        } else {\r\n            // Mode normal : charger avec un délai\r\n            setTimeout(() => {\r\n                this.doLoadElement(element);\r\n            }, Math.random() * 100); // Délai aléatoire pour éviter les pics\r\n        }\r\n    }\r\n\r\n    doLoadElement(element) {\r\n        // Marquer comme chargé\r\n        this.loadedElements.add(element.id);\r\n\r\n        // Notifer le canvas que l'élément est prêt\r\n        this.optimizer.canvas.emit('element-loaded', element);\r\n    }\r\n}\r\n\r\nclass PerformanceMonitor {\r\n    constructor(optimizer) {\r\n        this.optimizer = optimizer;\r\n        this.intervalId = null;\r\n        this.samples = [];\r\n        this.maxSamples = 100;\r\n    }\r\n\r\n    start() {\r\n        this.intervalId = setInterval(() => {\r\n            this.collectSample();\r\n        }, 1000); // Échantillon chaque seconde\r\n    }\r\n\r\n    stop() {\r\n        if (this.intervalId) {\r\n            clearInterval(this.intervalId);\r\n            this.intervalId = null;\r\n        }\r\n    }\r\n\r\n    collectSample() {\r\n        const sample = {\r\n            timestamp: Date.now(),\r\n            fps: this.optimizer.metrics.fps,\r\n            renderTime: this.optimizer.metrics.renderTime,\r\n            memoryUsage: this.optimizer.metrics.memoryUsage,\r\n            elementCount: this.optimizer.metrics.elementCount\r\n        };\r\n\r\n        this.samples.push(sample);\r\n\r\n        // Garder seulement les échantillons récents\r\n        if (this.samples.length > this.maxSamples) {\r\n            this.samples.shift();\r\n        }\r\n\r\n        // Analyser les tendances\r\n        this.analyzeTrends();\r\n    }\r\n\r\n    analyzeTrends() {\r\n        if (this.samples.length < 10) return;\r\n\r\n        const recent = this.samples.slice(-10);\r\n        const avgFps = recent.reduce((sum, s) => sum + s.fps, 0) / recent.length;\r\n        const avgRenderTime = recent.reduce((sum, s) => sum + s.renderTime, 0) / recent.length;\r\n\r\n        // Détecter les problèmes de performance\r\n        if (avgFps < 30) {\r\n            console.warn(`[PerformanceMonitor] Average FPS too low: ${avgFps.toFixed(1)}`);\r\n        }\r\n\r\n        if (avgRenderTime > 33) { // > 30fps\r\n            console.warn(`[PerformanceMonitor] Average render time too high: ${avgRenderTime.toFixed(1)}ms`);\r\n        }\r\n    }\r\n\r\n    getStats() {\r\n        if (this.samples.length === 0) return null;\r\n\r\n        const recent = this.samples.slice(-10);\r\n        return {\r\n            avgFps: recent.reduce((sum, s) => sum + s.fps, 0) / recent.length,\r\n            avgRenderTime: recent.reduce((sum, s) => sum + s.renderTime, 0) / recent.length,\r\n            minFps: Math.min(...recent.map(s => s.fps)),\r\n            maxFps: Math.max(...recent.map(s => s.fps)),\r\n            sampleCount: this.samples.length\r\n        };\r\n    }\r\n}","/**\r\n * PDF Canvas Vanilla - Classe principale pour le système Vanilla JS\r\n * Remplace les composants React avec une implémentation Canvas HTML5\r\n * Intègre les utilitaires migrés pour la gestion des éléments\r\n */\r\n\r\nimport { ELEMENT_PROPERTY_RESTRICTIONS, ELEMENT_TYPE_MAPPING, isPropertyAllowed, getPropertyDefault, validateProperty, fixInvalidProperty } from './pdf-canvas-elements.js';\r\nimport { WooCommerceElementsManager, wooCommerceElementsManager } from './pdf-canvas-woocommerce.js';\r\nimport { ElementCustomizationService, elementCustomizationService } from './pdf-canvas-customization.js';\r\nimport { PDFCanvasRenderer } from './pdf-canvas-renderer.js';\r\nimport { PDFCanvasEventManager } from './pdf-canvas-events.js';\r\nimport { PDFCanvasRenderUtils } from './pdf-canvas-render-utils.js';\r\nimport { PDFCanvasSelectionManager } from './pdf-canvas-selection.js';\r\nimport { PDFCanvasPropertiesManager } from './pdf-canvas-properties.js';\r\nimport { PDFCanvasLayersManager } from './pdf-canvas-layers.js';\r\nimport { PDFCanvasExportManager } from './pdf-canvas-export.js';\r\nimport { PDFCanvasPerformanceOptimizer } from './pdf-canvas-optimizer.js';\r\n\r\nexport class PDFCanvasVanilla {\r\n    constructor(containerId, options = {}) {\r\n        this.containerId = containerId;\r\n        this.options = {\r\n            width: options.width || 800,\r\n            height: options.height || 600,\r\n            backgroundColor: options.backgroundColor || '#ffffff',\r\n            gridSize: options.gridSize || 20,\r\n            showGrid: options.showGrid !== false,\r\n            zoom: options.zoom || 1,\r\n            ...options\r\n        };\r\n\r\n        // État du canvas\r\n        this.canvas = null;\r\n        this.ctx = null;\r\n        this.elements = new Map();\r\n        this.selectedElement = null;\r\n        this.dragState = null;\r\n        this.isInitialized = false;\r\n\r\n        // Gestionnaires d'événements\r\n        this.eventListeners = new Map();\r\n\r\n        // Services intégrés\r\n        this.wooCommerceManager = wooCommerceElementsManager;\r\n        this.customizationService = elementCustomizationService;\r\n\r\n        // Gestionnaires spécialisés\r\n        this.renderer = new PDFCanvasRenderer(this);\r\n        this.eventManager = new PDFCanvasEventManager(this);\r\n        this.selectionManager = new PDFCanvasSelectionManager(this);\r\n        this.propertiesManager = new PDFCanvasPropertiesManager(this);\r\n        this.layersManager = new PDFCanvasLayersManager(this);\r\n        this.exportManager = new PDFCanvasExportManager(this);\r\n        this.performanceOptimizer = new PDFCanvasPerformanceOptimizer(this);\r\n\r\n        // État d'interaction\r\n        this.mode = 'select'; // select, draw, text, etc.\r\n        this.tool = null;\r\n\r\n        // Historique pour undo/redo\r\n        this.history = [];\r\n        this.historyIndex = -1;\r\n    }\r\n\r\n    /**\r\n     * Initialise le canvas et les gestionnaires d'événements\r\n     */\r\n    async init() {\r\n        try {\r\n            // Créer le canvas\r\n            this.createCanvas();\r\n\r\n            // Configurer le contexte\r\n            this.setupContext();\r\n\r\n            // Attacher les gestionnaires d'événements\r\n            this.attachEventListeners();\r\n\r\n            // Charger les données WooCommerce si nécessaire\r\n            await this.loadInitialData();\r\n\r\n            // Premier rendu\r\n            this.render();\r\n\r\n            this.isInitialized = true;\r\n            console.log('PDFCanvasVanilla initialized successfully');\r\n\r\n        } catch (error) {\r\n            console.error('Failed to initialize PDFCanvasVanilla:', error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Crée l'élément canvas dans le conteneur\r\n     */\r\n    createCanvas() {\r\n        const container = document.getElementById(this.containerId);\r\n        if (!container) {\r\n            throw new Error(`Container with id \"${this.containerId}\" not found`);\r\n        }\r\n\r\n        // Vider le conteneur\r\n        container.innerHTML = '';\r\n\r\n        // Créer le canvas\r\n        this.canvas = document.createElement('canvas');\r\n        this.canvas.width = this.options.width;\r\n        this.canvas.height = this.options.height;\r\n        this.canvas.style.border = '1px solid #ddd';\r\n        this.canvas.style.cursor = 'default';\r\n        this.canvas.style.backgroundColor = this.options.backgroundColor;\r\n\r\n        // Ajouter au conteneur\r\n        container.appendChild(this.canvas);\r\n\r\n        // Obtenir le contexte\r\n        this.ctx = this.canvas.getContext('2d');\r\n        if (!this.ctx) {\r\n            throw new Error('Failed to get 2D context from canvas');\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Configure le contexte de rendu\r\n     */\r\n    setupContext() {\r\n        // Configuration de base\r\n        this.ctx.imageSmoothingEnabled = true;\r\n        this.ctx.imageSmoothingQuality = 'high';\r\n\r\n        // Configuration du texte\r\n        this.ctx.textBaseline = 'top';\r\n        this.ctx.font = '14px Arial, sans-serif';\r\n    }\r\n\r\n    /**\r\n     * Attache les gestionnaires d'événements DOM\r\n     */\r\n    attachEventListeners() {\r\n        // Gestionnaires de souris\r\n        this.canvas.addEventListener('mousedown', this.handleMouseDown.bind(this));\r\n        this.canvas.addEventListener('mousemove', this.handleMouseMove.bind(this));\r\n        this.canvas.addEventListener('mouseup', this.handleMouseUp.bind(this));\r\n        this.canvas.addEventListener('wheel', this.handleWheel.bind(this));\r\n\r\n        // Gestionnaires de clavier\r\n        document.addEventListener('keydown', this.handleKeyDown.bind(this));\r\n        document.addEventListener('keyup', this.handleKeyUp.bind(this));\r\n\r\n        // Gestionnaire de redimensionnement\r\n        window.addEventListener('resize', this.handleResize.bind(this));\r\n    }\r\n\r\n    /**\r\n     * Charge les données initiales\r\n     */\r\n    async loadInitialData() {\r\n        // Charger les données WooCommerce en mode test\r\n        this.wooCommerceManager.setTestMode(true);\r\n        await this.wooCommerceManager.loadWooCommerceData();\r\n    }\r\n\r\n    /**\r\n     * Gestionnaire d'événement mouse down\r\n     */\r\n    handleMouseDown(event) {\r\n        const point = this.getMousePosition(event);\r\n\r\n        switch (this.mode) {\r\n            case 'select':\r\n                this.handleSelectMode(point);\r\n                break;\r\n            case 'draw':\r\n                this.handleDrawMode(point);\r\n                break;\r\n            case 'text':\r\n                this.handleTextMode(point);\r\n                break;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gestionnaire d'événement mouse move\r\n     */\r\n    handleMouseMove(event) {\r\n        const point = this.getMousePosition(event);\r\n\r\n        if (this.dragState) {\r\n            this.handleDrag(point);\r\n        } else {\r\n            this.handleHover(point);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gestionnaire d'événement mouse up\r\n     */\r\n    handleMouseUp(event) {\r\n        if (this.dragState) {\r\n            this.endDrag();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gestionnaire de roulette de souris (zoom)\r\n     */\r\n    handleWheel(event) {\r\n        event.preventDefault();\r\n\r\n        const delta = event.deltaY > 0 ? 0.9 : 1.1;\r\n        this.setZoom(this.options.zoom * delta);\r\n    }\r\n\r\n    /**\r\n     * Gestionnaire de touches clavier\r\n     */\r\n    handleKeyDown(event) {\r\n        switch (event.key) {\r\n            case 'Delete':\r\n            case 'Backspace':\r\n                if (this.selectedElement) {\r\n                    this.deleteElement(this.selectedElement.id);\r\n                }\r\n                break;\r\n            case 'Escape':\r\n                this.deselectElement();\r\n                break;\r\n            case 'z':\r\n                if (event.ctrlKey || event.metaKey) {\r\n                    event.preventDefault();\r\n                    this.undo();\r\n                }\r\n                break;\r\n            case 'y':\r\n                if (event.ctrlKey || event.metaKey) {\r\n                    event.preventDefault();\r\n                    this.redo();\r\n                }\r\n                break;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gestionnaire de relâchement de touches\r\n     */\r\n    handleKeyUp(event) {\r\n        // Gérer les relâchements si nécessaire\r\n    }\r\n\r\n    /**\r\n     * Gestionnaire de redimensionnement de fenêtre\r\n     */\r\n    handleResize() {\r\n        // Ajuster la taille du canvas si nécessaire\r\n        this.render();\r\n    }\r\n\r\n    /**\r\n     * Obtient la position de la souris relative au canvas\r\n     */\r\n    getMousePosition(event) {\r\n        const rect = this.canvas.getBoundingClientRect();\r\n        return {\r\n            x: (event.clientX - rect.left) / this.options.zoom,\r\n            y: (event.clientY - rect.top) / this.options.zoom\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Gère le mode sélection\r\n     */\r\n    handleSelectMode(point) {\r\n        const element = this.getElementAtPoint(point);\r\n\r\n        if (element) {\r\n            this.selectElement(element.id);\r\n            this.startDrag(point);\r\n        } else {\r\n            this.deselectElement();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gère le mode dessin\r\n     */\r\n    handleDrawMode(point) {\r\n        // Implémentation du mode dessin\r\n        console.log('Draw mode at:', point);\r\n    }\r\n\r\n    /**\r\n     * Gère le mode texte\r\n     */\r\n    handleTextMode(point) {\r\n        // Implémentation du mode texte\r\n        console.log('Text mode at:', point);\r\n    }\r\n\r\n    /**\r\n     * Démarre un glisser-déposer\r\n     */\r\n    startDrag(point) {\r\n        if (!this.selectedElement) return;\r\n\r\n        this.dragState = {\r\n            startPoint: point,\r\n            elementStartPos: {\r\n                x: this.selectedElement.properties.x,\r\n                y: this.selectedElement.properties.y\r\n            }\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Gère le glisser-déposer\r\n     */\r\n    handleDrag(point) {\r\n        if (!this.dragState || !this.selectedElement) return;\r\n\r\n        const deltaX = point.x - this.dragState.startPoint.x;\r\n        const deltaY = point.y - this.dragState.startPoint.y;\r\n\r\n        this.updateElementProperty(this.selectedElement.id, 'x', this.dragState.elementStartPos.x + deltaX);\r\n        this.updateElementProperty(this.selectedElement.id, 'y', this.dragState.elementStartPos.y + deltaY);\r\n\r\n        this.render();\r\n    }\r\n\r\n    /**\r\n     * Termine le glisser-déposer\r\n     */\r\n    endDrag() {\r\n        this.dragState = null;\r\n        this.saveToHistory();\r\n    }\r\n\r\n    /**\r\n     * Gère le survol des éléments\r\n     */\r\n    handleHover(point) {\r\n        const element = this.getElementAtPoint(point);\r\n        this.canvas.style.cursor = element ? 'move' : 'default';\r\n    }\r\n\r\n    /**\r\n     * Sélectionne un élément\r\n     */\r\n    selectElement(elementId) {\r\n        this.selectedElement = this.elements.get(elementId);\r\n        this.render();\r\n    }\r\n\r\n    /**\r\n     * Désélectionne l'élément actuel\r\n     */\r\n    deselectElement() {\r\n        this.selectedElement = null;\r\n        this.render();\r\n    }\r\n\r\n    /**\r\n     * Obtient l'élément à une position donnée\r\n     */\r\n    getElementAtPoint(point) {\r\n        // Parcourir les éléments dans l'ordre inverse (dernier ajouté = premier cliqué)\r\n        const elementsArray = Array.from(this.elements.values()).reverse();\r\n\r\n        for (const element of elementsArray) {\r\n            if (this.isPointInElement(point, element)) {\r\n                return element;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Vérifie si un point est dans un élément\r\n     */\r\n    isPointInElement(point, element) {\r\n        const props = element.properties;\r\n        return point.x >= props.x &&\r\n               point.x <= props.x + props.width &&\r\n               point.y >= props.y &&\r\n               point.y <= props.y + props.height;\r\n    }\r\n\r\n    /**\r\n     * Ajoute un élément au canvas\r\n     */\r\n    addElement(type, properties = {}) {\r\n        const elementId = `element_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\r\n\r\n        // Obtenir les propriétés par défaut\r\n        const defaultProps = this.customizationService.getDefaultProperties(type);\r\n\r\n        // Fusionner avec les propriétés fournies\r\n        const elementProperties = { ...defaultProps, ...properties };\r\n\r\n        // Valider les propriétés\r\n        const validatedProps = {};\r\n        for (const [key, value] of Object.entries(elementProperties)) {\r\n            validatedProps[key] = this.customizationService.validateProperty(key, value);\r\n        }\r\n\r\n        const element = {\r\n            id: elementId,\r\n            type: type,\r\n            properties: validatedProps,\r\n            createdAt: Date.now(),\r\n            updatedAt: Date.now()\r\n        };\r\n\r\n        this.elements.set(elementId, element);\r\n        this.saveToHistory();\r\n        this.render();\r\n\r\n        return elementId;\r\n    }\r\n\r\n    /**\r\n     * Met à jour une propriété d'élément\r\n     */\r\n    updateElementProperty(elementId, property, value) {\r\n        const element = this.elements.get(elementId);\r\n        if (!element) return false;\r\n\r\n        // Valider la propriété\r\n        const validatedValue = this.customizationService.validateProperty(property, value);\r\n\r\n        // Vérifier les restrictions\r\n        if (!isPropertyAllowed(element.type, property)) {\r\n            console.warn(`Property \"${property}\" not allowed for element type \"${element.type}\"`);\r\n            return false;\r\n        }\r\n\r\n        element.properties[property] = validatedValue;\r\n        element.updatedAt = Date.now();\r\n\r\n        this.render();\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Supprime un élément\r\n     */\r\n    deleteElement(elementId) {\r\n        if (this.elements.delete(elementId)) {\r\n            if (this.selectedElement && this.selectedElement.id === elementId) {\r\n                this.selectedElement = null;\r\n            }\r\n            this.saveToHistory();\r\n            this.render();\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Définit le niveau de zoom\r\n     */\r\n    setZoom(zoom) {\r\n        this.options.zoom = Math.max(0.1, Math.min(5, zoom));\r\n        this.canvas.style.transform = `scale(${this.options.zoom})`;\r\n        this.canvas.style.transformOrigin = 'top left';\r\n    }\r\n\r\n    /**\r\n     * Définit le mode d'interaction\r\n     */\r\n    setMode(mode) {\r\n        this.mode = mode;\r\n        this.canvas.style.cursor = this.getCursorForMode(mode);\r\n    }\r\n\r\n    /**\r\n     * Obtient le curseur approprié pour un mode\r\n     */\r\n    getCursorForMode(mode) {\r\n        const cursors = {\r\n            select: 'default',\r\n            draw: 'crosshair',\r\n            text: 'text',\r\n            move: 'move'\r\n        };\r\n        return cursors[mode] || 'default';\r\n    }\r\n\r\n    /**\r\n     * Rend tous les éléments sur le canvas\r\n     */\r\n    render() {\r\n        // Utiliser l'optimiseur de performance si disponible\r\n        if (this.performanceOptimizer) {\r\n            this.performanceOptimizer.optimizeRendering();\r\n            return;\r\n        }\r\n\r\n        // Effacer le canvas\r\n        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\r\n\r\n        // Dessiner la grille si activée\r\n        if (this.options.showGrid) {\r\n            this.drawGrid();\r\n        }\r\n\r\n        // Dessiner tous les éléments\r\n        for (const element of this.elements.values()) {\r\n            this.renderElement(element);\r\n        }\r\n\r\n        // Dessiner les poignées de sélection\r\n        if (this.selectedElement) {\r\n            this.drawSelectionHandles(this.selectedElement);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Dessine la grille d'arrière-plan\r\n     */\r\n    drawGrid() {\r\n        const gridSize = this.options.gridSize;\r\n        this.ctx.strokeStyle = '#f0f0f0';\r\n        this.ctx.lineWidth = 1;\r\n\r\n        // Lignes verticales\r\n        for (let x = 0; x <= this.canvas.width; x += gridSize) {\r\n            this.ctx.beginPath();\r\n            this.ctx.moveTo(x, 0);\r\n            this.ctx.lineTo(x, this.canvas.height);\r\n            this.ctx.stroke();\r\n        }\r\n\r\n        // Lignes horizontales\r\n        for (let y = 0; y <= this.canvas.height; y += gridSize) {\r\n            this.ctx.beginPath();\r\n            this.ctx.moveTo(0, y);\r\n            this.ctx.lineTo(this.canvas.width, y);\r\n            this.ctx.stroke();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Rend un élément spécifique\r\n     */\r\n    renderElement(element) {\r\n        const props = element.properties;\r\n\r\n        // Sauvegarder le contexte\r\n        this.ctx.save();\r\n\r\n        // Appliquer les transformations\r\n        this.ctx.translate(props.x + props.width / 2, props.y + props.height / 2);\r\n        if (props.rotation) {\r\n            this.ctx.rotate((props.rotation * Math.PI) / 180);\r\n        }\r\n        this.ctx.translate(-props.width / 2, -props.height / 2);\r\n\r\n        // Appliquer l'opacité\r\n        if (props.opacity !== undefined && props.opacity < 100) {\r\n            this.ctx.globalAlpha = props.opacity / 100;\r\n        }\r\n\r\n        // Rendu selon le type d'élément\r\n        switch (element.type) {\r\n            case 'text':\r\n                this.renderTextElement(element);\r\n                break;\r\n            case 'rectangle':\r\n                this.renderRectangleElement(element);\r\n                break;\r\n            case 'image':\r\n                this.renderImageElement(element);\r\n                break;\r\n            default:\r\n                this.renderGenericElement(element);\r\n                break;\r\n        }\r\n\r\n        // Restaurer le contexte\r\n        this.ctx.restore();\r\n    }\r\n\r\n    /**\r\n     * Rend un élément texte\r\n     */\r\n    renderTextElement(element) {\r\n        const props = element.properties;\r\n\r\n        // Configuration du texte\r\n        this.ctx.font = `${props.fontWeight || 'normal'} ${props.fontSize || 14}px ${props.fontFamily || 'Arial, sans-serif'}`;\r\n        this.ctx.fillStyle = props.color || '#000000';\r\n        this.ctx.textAlign = props.textAlign || 'left';\r\n\r\n        // Position de départ\r\n        let x = 0;\r\n        let y = 0;\r\n\r\n        // Ajuster selon l'alignement\r\n        if (props.textAlign === 'center') {\r\n            x = props.width / 2;\r\n        } else if (props.textAlign === 'right') {\r\n            x = props.width;\r\n        }\r\n\r\n        // Rendu du texte\r\n        const text = props.text || 'Texte';\r\n        const lines = text.split('\\n');\r\n\r\n        for (let i = 0; i < lines.length; i++) {\r\n            this.ctx.fillText(lines[i], x, y + i * (props.fontSize || 14) * 1.2);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Rend un élément rectangle\r\n     */\r\n    renderRectangleElement(element) {\r\n        const props = element.properties;\r\n\r\n        // Fond\r\n        if (props.backgroundColor && props.backgroundColor !== 'transparent') {\r\n            this.ctx.fillStyle = props.backgroundColor;\r\n            this.roundRect(0, 0, props.width, props.height, props.borderRadius || 0);\r\n            this.ctx.fill();\r\n        }\r\n\r\n        // Bordure\r\n        if (props.borderWidth && props.borderWidth > 0) {\r\n            this.ctx.strokeStyle = props.borderColor || '#000000';\r\n            this.ctx.lineWidth = props.borderWidth;\r\n            this.roundRect(0, 0, props.width, props.height, props.borderRadius || 0);\r\n            this.ctx.stroke();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Rend un élément image\r\n     */\r\n    renderImageElement(element) {\r\n        const props = element.properties;\r\n\r\n        if (props.src) {\r\n            const img = new Image();\r\n            img.onload = () => {\r\n                // Calculer les dimensions pour le fit\r\n                let drawWidth = props.width;\r\n                let drawHeight = props.height;\r\n                let drawX = 0;\r\n                let drawY = 0;\r\n\r\n                if (props.objectFit === 'cover') {\r\n                    const scale = Math.max(props.width / img.width, props.height / img.height);\r\n                    drawWidth = img.width * scale;\r\n                    drawHeight = img.height * scale;\r\n                    drawX = (props.width - drawWidth) / 2;\r\n                    drawY = (props.height - drawHeight) / 2;\r\n                }\r\n\r\n                this.ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight);\r\n                this.render(); // Re-rendre après le chargement de l'image\r\n            };\r\n            img.src = props.src;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Rend un élément générique\r\n     */\r\n    renderGenericElement(element) {\r\n        // Rendu par défaut pour les éléments non reconnus\r\n        this.renderRectangleElement(element);\r\n    }\r\n\r\n    /**\r\n     * Dessine un rectangle avec des coins arrondis\r\n     */\r\n    roundRect(x, y, width, height, radius) {\r\n        if (radius === 0) {\r\n            this.ctx.rect(x, y, width, height);\r\n            return;\r\n        }\r\n\r\n        this.ctx.beginPath();\r\n        this.ctx.moveTo(x + radius, y);\r\n        this.ctx.lineTo(x + width - radius, y);\r\n        this.ctx.quadraticCurveTo(x + width, y, x + width, y + radius);\r\n        this.ctx.lineTo(x + width, y + height - radius);\r\n        this.ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);\r\n        this.ctx.lineTo(x + radius, y + height);\r\n        this.ctx.quadraticCurveTo(x, y + height, x, y + height - radius);\r\n        this.ctx.lineTo(x, y + radius);\r\n        this.ctx.quadraticCurveTo(x, y, x + radius, y);\r\n        this.ctx.closePath();\r\n    }\r\n\r\n    /**\r\n     * Dessine les poignées de sélection\r\n     */\r\n    drawSelectionHandles(element) {\r\n        const props = element.properties;\r\n        const handleSize = 8;\r\n\r\n        this.ctx.strokeStyle = '#007bff';\r\n        this.ctx.lineWidth = 2;\r\n        this.ctx.fillStyle = '#ffffff';\r\n\r\n        // Poignées de redimensionnement\r\n        const handles = [\r\n            { x: props.x, y: props.y }, // Haut-gauche\r\n            { x: props.x + props.width, y: props.y }, // Haut-droite\r\n            { x: props.x + props.width, y: props.y + props.height }, // Bas-droite\r\n            { x: props.x, y: props.y + props.height } // Bas-gauche\r\n        ];\r\n\r\n        handles.forEach(handle => {\r\n            this.ctx.fillRect(handle.x - handleSize/2, handle.y - handleSize/2, handleSize, handleSize);\r\n            this.ctx.strokeRect(handle.x - handleSize/2, handle.y - handleSize/2, handleSize, handleSize);\r\n        });\r\n\r\n        // Rectangle de sélection\r\n        this.ctx.strokeStyle = '#007bff';\r\n        this.ctx.setLineDash([5, 5]);\r\n        this.ctx.strokeRect(props.x, props.y, props.width, props.height);\r\n        this.ctx.setLineDash([]);\r\n    }\r\n\r\n    /**\r\n     * Sauvegarde l'état actuel dans l'historique\r\n     */\r\n    saveToHistory() {\r\n        const state = {\r\n            elements: new Map(this.elements),\r\n            selectedElement: this.selectedElement ? this.selectedElement.id : null\r\n        };\r\n\r\n        // Supprimer les états futurs si on est au milieu de l'historique\r\n        this.history = this.history.slice(0, this.historyIndex + 1);\r\n\r\n        // Ajouter le nouvel état\r\n        this.history.push(state);\r\n        this.historyIndex++;\r\n\r\n        // Limiter la taille de l'historique\r\n        if (this.history.length > 50) {\r\n            this.history.shift();\r\n            this.historyIndex--;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Annule la dernière action\r\n     */\r\n    undo() {\r\n        if (this.historyIndex > 0) {\r\n            this.historyIndex--;\r\n            this.restoreFromHistory();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Rétablit la dernière action annulée\r\n     */\r\n    redo() {\r\n        if (this.historyIndex < this.history.length - 1) {\r\n            this.historyIndex++;\r\n            this.restoreFromHistory();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Restaure l'état depuis l'historique\r\n     */\r\n    restoreFromHistory() {\r\n        const state = this.history[this.historyIndex];\r\n        this.elements = new Map(state.elements);\r\n        this.selectedElement = state.selectedElement ? this.elements.get(state.selectedElement) : null;\r\n        this.render();\r\n    }\r\n\r\n    /**\r\n     * Exporte le canvas en image\r\n     */\r\n    exportToImage(format = 'png', quality = 1) {\r\n        return this.canvas.toDataURL(`image/${format}`, quality);\r\n    }\r\n\r\n    /**\r\n     * Obtient les données JSON du canvas\r\n     */\r\n    exportToJSON() {\r\n        return {\r\n            version: '1.0',\r\n            canvas: {\r\n                width: this.options.width,\r\n                height: this.options.height,\r\n                backgroundColor: this.options.backgroundColor\r\n            },\r\n            elements: Array.from(this.elements.values()).map(element => ({\r\n                id: element.id,\r\n                type: element.type,\r\n                properties: element.properties,\r\n                createdAt: element.createdAt,\r\n                updatedAt: element.updatedAt\r\n            })),\r\n            metadata: {\r\n                exportedAt: Date.now(),\r\n                elementCount: this.elements.size\r\n            }\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Importe des données JSON dans le canvas\r\n     */\r\n    importFromJSON(data) {\r\n        try {\r\n            this.elements.clear();\r\n\r\n            data.elements.forEach(elementData => {\r\n                const element = {\r\n                    ...elementData,\r\n                    properties: { ...elementData.properties }\r\n                };\r\n                this.elements.set(element.id, element);\r\n            });\r\n\r\n            this.render();\r\n            this.saveToHistory();\r\n            return true;\r\n        } catch (error) {\r\n            console.error('Failed to import JSON:', error);\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Nettoie les ressources\r\n     */\r\n    dispose() {\r\n        // Supprimer les gestionnaires d'événements\r\n        if (this.canvas) {\r\n            this.canvas.removeEventListener('mousedown', this.handleMouseDown);\r\n            this.canvas.removeEventListener('mousemove', this.handleMouseMove);\r\n            this.canvas.removeEventListener('mouseup', this.handleMouseUp);\r\n            this.canvas.removeEventListener('wheel', this.handleWheel);\r\n        }\r\n\r\n        document.removeEventListener('keydown', this.handleKeyDown);\r\n        document.removeEventListener('keyup', this.handleKeyUp);\r\n        window.removeEventListener('resize', this.handleResize);\r\n\r\n        // Nettoyer les références\r\n        this.elements.clear();\r\n        this.selectedElement = null;\r\n        this.dragState = null;\r\n        this.history = [];\r\n        this.historyIndex = -1;\r\n\r\n        console.log('PDFCanvasVanilla disposed');\r\n    }\r\n\r\n    /**\r\n     * Obtient les statistiques du canvas\r\n     */\r\n    getStats() {\r\n        const baseStats = {\r\n            totalElements: this.elements.size,\r\n            selectedElement: this.selectedElement ? this.selectedElement.id : null,\r\n            canvasSize: {\r\n                width: this.canvas.width,\r\n                height: this.canvas.height\r\n            },\r\n            zoom: this.options.zoom,\r\n            mode: this.mode\r\n        };\r\n\r\n        // Ajouter les statistiques de performance si disponibles\r\n        if (this.performanceOptimizer) {\r\n            return {\r\n                ...baseStats,\r\n                performance: this.performanceOptimizer.getPerformanceStats()\r\n            };\r\n        }\r\n\r\n        return baseStats;\r\n    }\r\n}\r\n\r\n// Export de la classe\r\nexport default PDFCanvasVanilla;\r\n\r\n// Fonction d'initialisation globale pour WordPress\r\nwindow.pdfBuilderInitVanilla = function(containerId, options = {}) {\r\n    console.log('🚀 Initialisation Vanilla JS PDF Builder...');\r\n\r\n    try {\r\n        // Créer l'instance principale\r\n        const pdfCanvas = new PDFCanvasVanilla(containerId, options);\r\n\r\n        // Attendre que le DOM soit prêt\r\n        if (document.readyState === 'loading') {\r\n            document.addEventListener('DOMContentLoaded', () => {\r\n                pdfCanvas.init();\r\n            });\r\n        } else {\r\n            pdfCanvas.init();\r\n        }\r\n\r\n        // Exposer l'instance globalement pour le débogage\r\n        window.pdfBuilderInstance = pdfCanvas;\r\n\r\n        console.log('✅ PDF Builder Vanilla initialisé avec succès');\r\n        return pdfCanvas;\r\n\r\n    } catch (error) {\r\n        console.error('❌ Erreur lors de l\\'initialisation Vanilla:', error);\r\n        throw error;\r\n    }\r\n};\r\n\r\n// Alias pour la compatibilité\r\nwindow.pdfBuilderPro = {\r\n    init: window.pdfBuilderInitVanilla\r\n};\r\n"],"names":[],"sourceRoot":""}